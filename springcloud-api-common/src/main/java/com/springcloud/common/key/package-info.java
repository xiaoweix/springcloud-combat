/**
 * @author yueli
 * @date 2020/9/11 10:48
 */
package com.springcloud.common.key;
/**
 * 分布式自增id的实现方式
 * <p>
 * <p>
 * 第一种：数据库自增 id
 * 这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后 获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。
 * <p>
 * 这个方案的好处就是方便简单，谁都会用；缺点就是单库生成自增 id，要是高并发的话，就会有瓶颈的； 如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前 id 最大值，然后自己递增 几个 id，一次性返回一批
 * id，然后再把当前最大 id 值修改成递增几个 id 之后的一个值；但是无论如 何都是基于单个数据库。 适合的场景：你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你并发不高，
 * 但是数据量太大导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单 独的一个库和表生成自增主键即可
 * <p>
 * <p>
 * 第二种： 设置数据库 sequence 或者表自增字段步长
 * <p>
 * 可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。
 * 比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起 始ID 不同，并且依次递增，步长都是 8。
 * <p>
 * 适合的场景：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节 点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。
 * <p>
 * 第三种：UUID
 * <p>
 * 好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，作为主键性能太差 了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可 以产生部分顺序写），
 * 还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作， 将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较 大的情况下，性能下降明显。
 * <p>
 * 适用场景：如果你是要随机生成个什么文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID的
 * UUID..randomUUID().toString().replace(“-”, “”) -> sfsdf23423rr234sfdaf
 * <p>
 * <p>
 * 第四种：获取系统当前时间
 * <p>
 * 这个就是获取当前时间即可，但是问题是，并发很高的时候，比如一秒并发几千，会有重复的情况，这个是 肯定不合适的。基本就不用考虑了。
 * 适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业 务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一 的编号。
 * <p>
 * 第五种：snowflake 算法
 * snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit
 * 作为工作机器 id，12 bit 作为序列号。
 *
 */


